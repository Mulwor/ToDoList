import {tasksReducer} from "../Unit-test/Tasks/Tasks-reducer";
import {todoListsReducer} from "../Unit-test/ToDoList/Todolists-reducer";
import { combineReducers, legacy_createStore } from 'redux'

// Редакс - это управления для хранения состояния и приложения. Состояние и приложение хранится в обычном объекте.
// Этот объект называется store. Он состоит из свойство state (где лежат данные и методов getState, dispatch and subscribe)
// Построен редакс на flux-архитектуре. Это однонаправленный поток данных, без редакса мы прокидываем все через пропсы с одного компонента
// на другой. Когда ншае приложение подключено к редаксу,
// мы из любой приложение можем получить данные. Когда запускается наше приложение то сразу же запускаются все наши редюсеры
// проверяются и наши редюсеры обязательно должны что-то вернуть

// Когда основной метод dispatch нужен action? - Когда мы вызываем метод dispatch, пользователь там что-то сделал на юае, отдаем ему
// экшн для того, чтобы не вычислять редюсер, запускается все редюсеры, которые есть в приложении и если в них находится кейс при котором
// происходит изменения стейта, а если не происходит изменения то возвращает нам state.

// Как происходит подключение, так как данные реакта лежат отдельно и данные редакса отдельно. Подключение происходит с помощью того, что
// что мы помещаем наш объект store в контекст нашего приложения и с помощью компонента provider из библиотеки реакт-редакс

// 3 принципа редакса: данные хранятся в одном месте - это объект store, данные нельзя менять напрямую, только мутаббельно, данные изменяются с
// помощью чистой функции редюсеры

// C помощью чего в функциональных компонентов можно добраться к store => через хук useSelector (в функциональных компонента), а для получения метода dispatch
// используется useDispatch(), а в классовых компонентов хук connect

/*
    1. Редакс состоит из store, а он в свою очередь является объектом и он всегда 1. Внутри store хранится state и работает с одним объектом:
    стор создается благодаря функции export const store = legacy_createStore(rootReducer) который берет данные из корневого редюсера

   {store -> state: {
     task: {}
     todolists: {}
   },
    getState() 
    dispatch()
    subsricbe()
   }

   Чтобы создать его необходимо написать createStore => const store = createStore(rootReducer)


   2. Нужен для обращение в браузере через консоль, однако, чтобы тайпскрипт
   не ругался нужно комментарием написать @ts-ignore:
   window.store = store


   3. И необходимо создавать store с редюсеррами а их у нас 2. И необходимо эти редюсеры объединить через combineReducers. 
   Принимает объект в виде ключа (названия сами придумаем) и значения (определенный редюсер). Это так называемый корневой 
   редюсер, который будет получать все Экшены, а дальше он будет раскидывать все экшены остальным редюсерам

   const rootReducer = combineReducers({ tasks: tasksReducer, todoLists: todoListsReducer })

    4. AppRootStateType => Необходим для автоматической типизация объекта состояние. Работает следующим образом: <typeof rootReducer> - определи какой это тип и врени мне его
*/

const rootReducer = combineReducers({
    tasks: tasksReducer,
    todoLists: todoListsReducer
})
export const store = legacy_createStore(rootReducer)
export type AppRootStateType = ReturnType<typeof rootReducer>

// @ts-ignore
window.store = store