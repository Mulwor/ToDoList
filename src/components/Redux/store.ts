import {tasksReducer} from "../Unit-test/Tasks/Tasks-reducer";
import {todoListsReducer} from "../Unit-test/ToDoList/Todolists-reducer";
import { combineReducers, legacy_createStore } from 'redux'

/*
    Редакс - это инструмент для управления состоянием данных. Состояние и приложение хранится в обычном объекте
  (store). Тот в свою очередь состоит из свойства state, где лежат данные и методов getState, dispatch and 
  subscribe. 

      С помощью хука useSelector  можно добраться к store (в функциональных компонента), а для получения метода 
  dispatch используется useDispatch(), а в классовых компонентов хук connect

  store => state: { 
    task: {}, todolists: {}
  }, 
    getState(), 
    dispatch(), 
    subsricbe()
  }

    И этот store создает благодаря export const store = legacy_createStore(rootReducer), который берет 
  данные из корневого редюсера. 

    В корневом элементе создаются редюсеры, которые объединяются через combineReducers. Принимает объект в виде 
  ключа и значения (определенный редюсер). Корневой редюсер получает экшены, а дальше он раскидывает
  все экшены остальным редюсерам

    Как происходит подключение? - Так как данные реакта лежат отдельно и данные редакса отдельно. Подключение 
  происходит с помощью того, что, мы помещаем наш объект store в контекст нашего приложения и с помощью 
  компонента provider из библиотеки реакт-редакс
  
    Стоит отметить, что редакс построен на flux-архитектуре. Это однонаправленный поток данных, без редакса 
  мы прокидываем все через пропсы с одного компонента. Когда наша приложение подключено к редаксу, мы из любого
  место нашего приложения можем получить данные. Когда запускается наше приложение то сразу же запускаются все
  наши редюсеры и проверяются и наши редюсеры обязательно должны что-то вернуть (initialState)

    Когда основному методу dispatch нужен action? - Когда мы вызываем метод dispatch, пользователь там что-то 
  сделал на юае, отдаем ему экшн для того, чтобы не вычислять редюсер, запускается все редюсеры, которые есть 
  в приложении и если в них находится кейс при котором происходит изменения стейта, а если не происходит 
  изменения то возвращает нам state.

  В основе есть 3 принципа реакт: 
  1. Данные хранятся в одном месте - Это объект store, 
  2. Данные нельзя менять напрямую, только мутаббельно, 
  2. Данные изменяются с помощью чистой функции редюсеры

    С помощью хука useSelector  можно добраться к store (в функциональных компонента), а для получения метода 
  dispatch используется useDispatch(), а в классовых компонентов хук connect
*/


const rootReducer = combineReducers({
    tasks: tasksReducer,
    todoLists: todoListsReducer
})
export const store = legacy_createStore(rootReducer)

// AppRootStateType => Необходим для автоматической типизация объекта состояние. Работает через: <typeof rootReducer> -
// определи какой это тип и верни мне его
export type AppRootStateType = ReturnType<typeof rootReducer>


// Нужен для обращение в браузере через консоль, однако, чтобы тайпскрипт не ругался нужно комментарием написать 
// @ts-ignore
window.store = store